# -*- coding: utf-8 -*-
"""Climate Change.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NOsM9BkgqavyQooNygMzsH_tPFrhSQ0L
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from  datetime import datetime,timedelta
import matplotlib.pyplot as plt
import numpy as np
from statsmodels.tsa.seasonal import seasonal_decompose
import seaborn as sns

# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')

temperature = pd.read_csv('/content/temperature_month.csv')

temperature.head()

temperature.dtypes

temperature.shape

temperature.rename(columns ={'Year':"Date"}, inplace =True)
print(temperature)

temperature['Date'] = pd.to_datetime(temperature['Date'])
temperature.set_index('Date', inplace =True)
temperature.index

temperature.describe()

temperature['Year'] = temperature.index.year
temperature.head()

temperature.describe()

plt.figure(figsize =(9,4))
sns.lineplot(x ='Year', y ='Average Temperature', data = temperature)
plt.show()

temperature_new =temperature.loc['2000':'2022']
temperature_new.head()

resample_temperature = temperature_new[['Average Temperature']].resample('A').mean()

resample_temperature.head()

resample_temperature.plot(title = 'Temperature  Changes from 2000-2022', figsize =(8,5))
plt.ylabel('Temperature', fontsize = 12)
plt.xlabel('Year', fontsize =12)
plt.legend()

"""*Check Stationarity*"""

from statsmodels.tsa.stattools import adfuller
print('Dickey Fuller Test Results')
test_df = adfuller(resample_temperature.iloc[:,0].values, autolag ='AIC')
output = pd.Series(test_df[0:4], index =['Test Statistic','p-value','Lags used', 'Number of Observations Used'])
for key, value in test_df[4].items():
  output['Critical Value (%s)' %key] = value
print(output)

"""Time series is not stationary

"""

decomp = seasonal_decompose(resample_temperature)


trend = decomp.trend
seasonal = decomp.seasonal
residual = decomp.resid

plt.subplot(411)
plt.plot(resample_temperature)
plt.xlabel('Original')
plt.figure(figsize =(6,5))


plt.subplot(411)
plt.plot(trend)
plt.xlabel('Trend')
plt.figure(figsize =(6,5))



plt.subplot(411)
plt.plot(seasonal)
plt.xlabel('Season')
plt.figure(figsize =(6,5))



plt.subplot(411)
plt.plot(residual)
plt.xlabel('Residual')
plt.figure(figsize =(6,5))


plt.tight_layout()

roling_mean = resample_temperature.rolling(window =3, center =True).mean()
exponential_weighted_mean =resample_temperature.ewm(span =3).mean()

rol_std = resample_temperature.rolling(window =3, center =True).std()

fig,(ax1,ax2) = plt.subplots(1,2, figsize =(12,5))
ax1.plot(resample_temperature, label ='original')
ax1.plot(roling_mean, label ='Rolling Mean')
ax1.plot(exponential_weighted_mean, label = "Exponential Weighted Mean")
ax1.set_title('Temperature changes from 2000-2022', fontsize=14)
ax1.set_ylabel('Temperature', fontsize =12)
ax1.set_xlabel('Year', fontsize =12)
ax1.legend()


ax2.plot(rol_std, label = 'Rolling STD')
ax2.set_title('Temperature Changes from 2000-2022', fontsize =14)
ax2.set_ylabel('Temperature', fontsize = 12)
ax2.set_xlabel('Year', fontsize = 12)
ax2.legend()

plt.tight_layout()
plt.show()

roling_mean.dropna(inplace =True)
exponential_weighted_mean.dropna(inplace =True)
print('Dickey Fuller Test Results')
test_df = adfuller(roling_mean.iloc[:,0].values, autolag ='AIC')
output = pd.Series(test_df[0:4], index =['Test Statistic','p-value','Lags used', 'Number of Observations Used'])
for key, value in test_df[4].items():
  output['Critical Value (%s)' %key] = value
print(output)
print('')
print('Dickey Fuller Test Results')
test_df = adfuller(exponential_weighted_mean.iloc[:,0].values, autolag ='AIC')
output = pd.Series(test_df[0:4], index =['Test Statistic','p-value','Lags used', 'Number of Observations Used'])
for key, value in test_df[4].items():
  output['Critical Value (%s)' %key] = value
print(output)

diff_rol_mean = resample_temperature - roling_mean
diff_rol_mean.dropna(inplace =True)
diff_rol_mean.head()

diff_ewm = resample_temperature - exponential_weighted_mean
diff_ewm.dropna()

df_rol_mean_diff = diff_rol_mean.rolling(window=3, center =True).mean()

df_ewm_diff = diff_ewm.ewm(span =3).mean()
fig,(ax1,ax2) = plt.subplots(1,2, figsize =(12,5))
ax1.plot(diff_rol_mean, label ='original')
ax1.plot(df_rol_mean_diff, label ='Rolling Mean')
ax1.set_title('Temperature changes from 2000-2022', fontsize=14)
ax1.set_ylabel('Temperature', fontsize =12)
ax1.set_xlabel('Year', fontsize =12)
ax1.legend()


ax2.plot(diff_ewm, label = 'original')
ax2.plot(df_ewm_diff, label = 'exponential weighted mean')

ax2.set_title('Temperature Changes from 2000-2022', fontsize =14)
ax2.set_ylabel('Temperature', fontsize = 12)
ax2.set_xlabel('Year', fontsize = 12)
ax2.legend()

plt.tight_layout()
plt.show()

print('Dickey Fuller Test Results')
test_df = adfuller(diff_rol_mean.iloc[:,0].values, autolag ='AIC')
output = pd.Series(test_df[0:4], index =['Test Statistic','p-value','Lags used', 'Number of Observations Used'])
for key, value in test_df[4].items():
  output['Critical Value (%s)' %key] = value
print(output)
print('')
print('Dickey Fuller Test Results')
test_df = adfuller(diff_ewm.iloc[:,0].values, autolag ='AIC')
output = pd.Series(test_df[0:4], index =['Test Statistic','p-value','Lags used', 'Number of Observations Used'])
for key, value in test_df[4].items():
  output['Critical Value (%s)' %key] = value
print(output)

"""In this case time series is stationary"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt

# Assuming resample_temperature is your time series
# Adjust nlags to be less than half the length of your time series
nlags = min(len(resample_temperature) // 2 - 1, 6)

plt.figure(figsize=(12, 8))

# Plotting ACF
plt.subplot(211)
plot_acf(resample_temperature, lags=nlags, ax=plt.gca())

# Plotting PACF
plt.subplot(212)
plot_pacf(resample_temperature, lags=nlags, ax=plt.gca())

plt.show()

from statsmodels.tsa.arima.model import ARIMA

# Fit ARIMA model
p, d, q = 1, 1, 1  # Adjust these values based on your analysis

model = ARIMA(diff_rol_mean.iloc[:, 0], order=(p, d, q))
results = model.fit()

# Print model summary
print(results.summary())